rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users can only access their own data
    match /users/{userId} {
      // Allow read and write only if authenticated user's UID matches document ID
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Prevent creation of documents with mismatched IDs
      allow create: if request.auth != null
                    && request.auth.uid == userId
                    && request.auth.uid == resource.id;

      // Allow updates only to own data with valid structure
      allow update: if request.auth != null
                    && request.auth.uid == userId
                    && isValidUserData(request.resource.data);

      // Allow delete only of own data
      allow delete: if request.auth != null && request.auth.uid == userId;

      // Child Safety PIN settings subcollection
      match /settings/childSafety {
        // Only the authenticated user can read/write their own PIN settings
        allow read, write: if request.auth != null && request.auth.uid == userId;

        // Validate PIN data structure on create/update
        allow create, update: if request.auth != null
                              && request.auth.uid == userId
                              && isValidPINData(request.resource.data);
      }

      // Notifications subcollection
      match /notifications/{notificationId} {
        // Only the authenticated user can read their own notifications
        allow read: if request.auth != null && request.auth.uid == userId;

        // Allow create/update when the payload belongs to the user and matches the schema
        allow create, update: if request.auth != null
                              && request.auth.uid == userId
                              && request.resource.data.userId == userId
                              && isValidNotificationData(request.resource.data);

        // Allow deletes when the existing notification belongs to the user
        allow delete: if request.auth != null
                      && request.auth.uid == userId
                      && resource.data.userId == userId;
      }

      // Interactions subcollection (for recommendation tracking)
      match /interactions/{interactionId} {
        // Only the authenticated user can read/write their own interactions
        allow read, write: if request.auth != null && request.auth.uid == userId;

        // Validate interaction data structure on create/update
        allow create, update: if request.auth != null
                              && request.auth.uid == userId
                              && isValidInteractionData(request.resource.data);
      }

      // Interaction summary document (for recommendation tracking)
      match /interactionSummary/summary {
        // Only the authenticated user can read/write their own interaction summary
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Data subcollection - watch history document
      match /data/watchHistory {
        // Only the authenticated user can access their watch history
        allow read, delete: if request.auth != null && request.auth.uid == userId;

        // Validate watch history structure on create/update
        allow create, update: if request.auth != null
                              && request.auth.uid == userId
                              && isValidWatchHistoryData(request.resource.data);
      }
    }

    // Helper function to validate user data structure (NEW SCHEMA)
    function isValidUserData(data) {
      // Required fields for new schema
      return data.keys().hasAll(['defaultWatchlist', 'likedMovies', 'hiddenMovies', 'userCreatedWatchlists', 'lastActive'])
             && data.defaultWatchlist is list
             && data.likedMovies is list
             && data.hiddenMovies is list
             && data.userCreatedWatchlists is list
             && data.lastActive is number
             // Optional preference fields
             && (!data.keys().hasAny(['autoMute']) || data.autoMute is bool)
             && (!data.keys().hasAny(['defaultVolume']) || data.defaultVolume is number)
             && (!data.keys().hasAny(['childSafetyMode']) || data.childSafetyMode is bool)
             && (!data.keys().hasAny(['improveRecommendations']) || data.improveRecommendations is bool);
    }

    // Helper function to validate PIN data structure
    function isValidPINData(data) {
      return data.keys().hasAll(['hash', 'createdAt', 'lastChangedAt', 'enabled'])
             && data.hash is string
             && data.hash.size() > 0  // bcrypt hash should not be empty
             && data.createdAt is number
             && data.lastChangedAt is number
             && data.enabled is bool
             && (!data.keys().hasAny(['failedAttempts']) || data.failedAttempts is number)
             && (!data.keys().hasAny(['rateLimitResetAt']) || data.rateLimitResetAt is number);
    }

    // Helper function to validate notification data structure
    function isValidNotificationData(data) {
      return data.keys().hasAll(['id', 'userId', 'type', 'title', 'message', 'isRead', 'createdAt'])
             && data.id is string
             && data.userId is string
             && data.type is string
             && data.title is string
             && data.message is string
             && data.isRead is bool
             && data.createdAt is number
             // Optional fields
             && (!data.keys().hasAny(['contentId']) || data.contentId is number)
             && (!data.keys().hasAny(['collectionId']) || data.collectionId is string)
             && (!data.keys().hasAny(['shareId']) || data.shareId is string)
             && (!data.keys().hasAny(['actionUrl']) || data.actionUrl is string)
             && (!data.keys().hasAny(['imageUrl']) || data.imageUrl is string)
             && (!data.keys().hasAny(['expiresAt']) || data.expiresAt is number);
    }

    // Helper function to validate interaction data structure
    function isValidInteractionData(data) {
      return data.keys().hasAll(['id', 'userId', 'contentId', 'mediaType', 'interactionType', 'timestamp', 'genreIds'])
             && data.id is string
             && data.userId is string
             && data.contentId is number
             && data.mediaType is string
             && data.interactionType is string
             && data.timestamp is number
             && data.genreIds is list
             // Optional fields
             && (!data.keys().hasAny(['trailerDuration']) || data.trailerDuration is number)
             && (!data.keys().hasAny(['searchQuery']) || data.searchQuery is string)
             && (!data.keys().hasAny(['collectionId']) || data.collectionId is string)
             && (!data.keys().hasAny(['source']) || data.source is string);
    }

    // Helper function to validate watch history document
    function isValidWatchHistoryData(data) {
      return data.keys().hasAll(['history', 'updatedAt'])
             && data.history is list
             && data.updatedAt is number;
    }

    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
