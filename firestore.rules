rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users can only access their own data
    match /users/{userId} {
      // BASIC ACCESS CONTROL
      allow read: if request.auth != null && request.auth.uid == userId;
      allow delete: if request.auth != null && request.auth.uid == userId;

      // Prevent creation of documents with mismatched IDs and enforce schema
      allow create: if request.auth != null
                    && request.auth.uid == userId
                    && request.auth.uid == resource.id
                    && isValidUserData(request.resource.data);

      // Only allow updates to documents owned by the caller that match the schema
      allow update: if request.auth != null
                    && request.auth.uid == userId
                    && isValidUserData(request.resource.data);

      // Child Safety PIN settings subcollection
      match /settings/childSafety {
        // Only the authenticated user can read/write their own PIN settings
        allow read, write: if request.auth != null && request.auth.uid == userId;

        // Validate PIN data structure on create/update
        allow create, update: if request.auth != null
                              && request.auth.uid == userId
                              && isValidPINData(request.resource.data);
      }

      // Notifications subcollection
      match /notifications/{notificationId} {
        // Only the authenticated user can read their own notifications
        allow read: if request.auth != null && request.auth.uid == userId;

        // Allow create/update when the payload belongs to the user and matches the schema
        allow create, update: if request.auth != null
                              && request.auth.uid == userId
                              && request.resource.data.userId == userId
                              && isValidNotificationData(request.resource.data);

        // Allow deletes when the existing notification belongs to the user
        allow delete: if request.auth != null
                      && request.auth.uid == userId
                      && resource.data.userId == userId;
      }

      // Interactions subcollection (for recommendation tracking)
      match /interactions/{interactionId} {
        // Only the authenticated user can read/write their own interactions
        allow read, write: if request.auth != null && request.auth.uid == userId;

        // Validate interaction data structure on create/update
        allow create, update: if request.auth != null
                              && request.auth.uid == userId
                              && isValidInteractionData(request.resource.data);
      }

      // Interaction summary document (for recommendation tracking)
      match /interactionSummary/summary {
        // Only the authenticated user can read/write their own interaction summary
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Data subcollection - watch history document
      // Using wildcard to match any document in the data subcollection
      match /data/{dataDoc=**} {
        // Allow all operations if authenticated user matches the parent userId
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Drafts subcollection (for ranking drafts)
      match /drafts/{draftId} {
        // Only the authenticated user can read/write their own drafts
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Helper function to validate user data structure (NEW SCHEMA)
    function isValidUserData(data) {
      // Required fields for new schema
      return data.keys().hasAll(['defaultWatchlist', 'likedMovies', 'hiddenMovies', 'userCreatedWatchlists', 'lastActive'])
             && data.defaultWatchlist is list
             && data.likedMovies is list
             && data.hiddenMovies is list
             && data.userCreatedWatchlists is list
             && data.lastActive is number
             // Optional preference fields
             && (!data.keys().hasAny(['autoMute']) || data.autoMute is bool)
             && (!data.keys().hasAny(['defaultVolume']) || data.defaultVolume is number)
             && (!data.keys().hasAny(['childSafetyMode']) || data.childSafetyMode is bool)
             && (!data.keys().hasAny(['improveRecommendations']) || data.improveRecommendations is bool);
    }

    // Helper function to validate PIN data structure
    function isValidPINData(data) {
      return data.keys().hasAll(['hash', 'createdAt', 'lastChangedAt', 'enabled'])
             && data.hash is string
             && data.hash.size() > 0  // bcrypt hash should not be empty
             && data.createdAt is number
             && data.lastChangedAt is number
             && data.enabled is bool
             && (!data.keys().hasAny(['failedAttempts']) || data.failedAttempts is number)
             && (!data.keys().hasAny(['rateLimitResetAt']) || data.rateLimitResetAt is number);
    }

    // Helper function to validate notification data structure
    function isValidNotificationData(data) {
      return data.keys().hasAll(['id', 'userId', 'type', 'title', 'message', 'isRead', 'createdAt'])
             && data.id is string
             && data.userId is string
             && data.type is string
             && data.title is string
             && data.message is string
             && data.isRead is bool
             && data.createdAt is number
             // Optional fields
             && (!data.keys().hasAny(['contentId']) || data.contentId is number)
             && (!data.keys().hasAny(['collectionId']) || data.collectionId is string)
             && (!data.keys().hasAny(['shareId']) || data.shareId is string)
             && (!data.keys().hasAny(['actionUrl']) || data.actionUrl is string)
             && (!data.keys().hasAny(['imageUrl']) || data.imageUrl is string)
             && (!data.keys().hasAny(['expiresAt']) || data.expiresAt is number);
    }

    // Helper function to validate interaction data structure
    function isValidInteractionData(data) {
      return data.keys().hasAll(['id', 'userId', 'contentId', 'mediaType', 'interactionType', 'timestamp', 'genreIds'])
             && data.id is string
             && data.userId is string
             && data.contentId is number
             && data.mediaType is string
             && data.interactionType is string
             && data.timestamp is number
             && data.genreIds is list
             // Optional fields
             && (!data.keys().hasAny(['trailerDuration']) || data.trailerDuration is number)
             && (!data.keys().hasAny(['searchQuery']) || data.searchQuery is string)
             && (!data.keys().hasAny(['collectionId']) || data.collectionId is string)
             && (!data.keys().hasAny(['source']) || data.source is string);
    }

    // Helper function to validate watch history document
    function isValidWatchHistoryData(data) {
      return data.keys().hasAll(['history', 'updatedAt'])
             && data.history is list
             && data.updatedAt is number;
    }

    // Rankings collection (public and private rankings)
    match /rankings/{rankingId} {
      // Allow read if authenticated (to view rankings in community and clone)
      // Private rankings are filtered client-side in queries
      allow read: if request.auth != null;

      // Allow create if authenticated and userId matches auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && isValidRankingData(request.resource.data);

      // Allow update if authenticated user is the owner OR if only incrementing views/likes/comments
      allow update: if request.auth != null && (
                      // Owner can update anything
                      (request.auth.uid == resource.data.userId
                       && request.resource.data.userId == resource.data.userId
                       && isValidRankingData(request.resource.data))
                      ||
                      // Anyone authenticated can increment views/likes/comments
                      (isOnlyIncrementingStats(resource.data, request.resource.data))
                    );

      // Allow delete if authenticated user is the owner
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // Ranking comments collection
    match /ranking_comments/{commentId} {
      // Allow read for all authenticated users
      allow read: if request.auth != null;

      // Allow create if authenticated and userId matches auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && isValidCommentData(request.resource.data);

      // Allow update if authenticated user is the comment owner (for replies array)
      allow update: if request.auth != null
                    && request.auth.uid == resource.data.userId;

      // Allow delete if authenticated user is the comment owner
      // OR if authenticated user is the ranking owner
      allow delete: if request.auth != null
                    && (request.auth.uid == resource.data.userId
                    || request.auth.uid == get(/databases/$(database)/documents/rankings/$(resource.data.rankingId)).data.userId);
    }

    // Comment likes collection
    match /comment_likes/{likeId} {
      // Allow read for all authenticated users
      allow read: if request.auth != null;

      // Allow create if authenticated and userId in document matches auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid;

      // Allow delete if authenticated user owns the like
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // Ranking likes collection
    match /ranking_likes/{likeId} {
      // Allow read for all authenticated users
      allow read: if request.auth != null;

      // Allow create if authenticated and userId in document matches auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid;

      // Allow delete if authenticated user owns the like
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // Helper function to validate ranking data structure
    function isValidRankingData(data) {
      return data.keys().hasAll(['id', 'userId', 'userName', 'title', 'itemCount', 'isPublic', 'rankedItems', 'likes', 'views', 'comments', 'createdAt', 'updatedAt'])
             && data.id is string
             && data.userId is string
             && data.userName is string
             && data.title is string
             && data.itemCount is number
             && data.isPublic is bool
             && data.rankedItems is list
             && data.likes is number
             && data.views is number
             && data.comments is number
             && data.createdAt is number
             && data.updatedAt is number;
    }

    // Helper function to validate comment data structure
    function isValidCommentData(data) {
      return data.keys().hasAll(['id', 'rankingId', 'userId', 'userName', 'type', 'text', 'createdAt', 'likes'])
             && data.id is string
             && data.rankingId is string
             && data.userId is string
             && data.userName is string
             && data.type is string
             && data.text is string
             && data.createdAt is number
             && data.likes is number;
    }

    // Helper function to check if only stats are being incremented
    function isOnlyIncrementingStats(before, after) {
      // Only allow increment/decrement by exactly 1 for each stat
      // This prevents users from manipulating stats by arbitrary amounts
      return after.id == before.id
             && after.userId == before.userId
             && after.userName == before.userName
             && after.title == before.title
             && after.itemCount == before.itemCount
             && after.isPublic == before.isPublic
             && after.rankedItems == before.rankedItems
             && after.createdAt == before.createdAt
             && after.updatedAt == before.updatedAt
             // Only allow one stat to change at a time, by exactly 1 or -1
             && (
                 // Views increment by 1
                 (after.views == before.views + 1 && after.likes == before.likes && after.comments == before.comments)
                 // Likes increment by 1
                 || (after.likes == before.likes + 1 && after.views == before.views && after.comments == before.comments)
                 // Likes decrement by 1
                 || (after.likes == before.likes - 1 && after.views == before.views && after.comments == before.comments)
                 // Comments increment by 1
                 || (after.comments == before.comments + 1 && after.views == before.views && after.likes == before.likes)
                 // Comments decrement by 1
                 || (after.comments == before.comments - 1 && after.views == before.views && after.likes == before.likes)
             );
    }

    // ==========================================
    // Forum Features: Threads, Polls, Replies
    // ==========================================

    // Discussion threads collection
    match /threads/{threadId} {
      // Allow read for all authenticated users
      allow read: if request.auth != null;

      // Allow create if authenticated and userId matches auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && isValidThreadData(request.resource.data);

      // Allow update if authenticated user is the owner OR if only incrementing stats
      allow update: if request.auth != null && (
                      // Owner can update anything
                      (request.auth.uid == resource.data.userId
                       && request.resource.data.userId == resource.data.userId
                       && isValidThreadData(request.resource.data))
                      ||
                      // Anyone authenticated can increment views/likes/replyCount
                      (isOnlyIncrementingThreadStats(resource.data, request.resource.data))
                    );

      // Allow delete if authenticated user is the owner
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // Thread replies collection
    match /thread_replies/{replyId} {
      // Allow read for all authenticated users
      allow read: if request.auth != null;

      // Allow create if authenticated and userId matches auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && isValidThreadReplyData(request.resource.data);

      // Allow update if authenticated user is the owner (for editing)
      allow update: if request.auth != null
                    && request.auth.uid == resource.data.userId;

      // Allow delete if authenticated user is the reply owner
      // OR if authenticated user is the thread owner
      allow delete: if request.auth != null
                    && (request.auth.uid == resource.data.userId
                    || request.auth.uid == get(/databases/$(database)/documents/threads/$(resource.data.threadId)).data.userId);
    }

    // Thread likes collection
    match /thread_likes/{likeId} {
      // Allow read for all authenticated users
      allow read: if request.auth != null;

      // Allow create if authenticated and userId matches auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid;

      // Allow delete if authenticated user owns the like
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // Reply likes collection
    match /reply_likes/{likeId} {
      // Allow read for all authenticated users
      allow read: if request.auth != null;

      // Allow create if authenticated and userId matches auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid;

      // Allow delete if authenticated user owns the like
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // Polls collection
    match /polls/{pollId} {
      // Allow read for all authenticated users
      allow read: if request.auth != null;

      // Allow create if authenticated and userId matches auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && isValidPollData(request.resource.data);

      // Allow update if authenticated user is the owner OR if only incrementing totalVotes
      allow update: if request.auth != null && (
                      // Owner can update anything
                      (request.auth.uid == resource.data.userId
                       && request.resource.data.userId == resource.data.userId
                       && isValidPollData(request.resource.data))
                      ||
                      // Anyone authenticated can update vote counts
                      (isOnlyUpdatingPollVotes(resource.data, request.resource.data))
                    );

      // Allow delete if authenticated user is the owner
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // Poll votes collection
    match /poll_votes/{voteId} {
      // Allow read for all authenticated users
      allow read: if request.auth != null;

      // Allow create if authenticated and userId matches auth
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid;

      // Allow delete if authenticated user owns the vote
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;

      // Don't allow updates - votes are immutable once cast
    }

    // Helper function to validate thread data structure
    function isValidThreadData(data) {
      return data.keys().hasAll(['id', 'title', 'content', 'category', 'userId', 'userName', 'createdAt', 'updatedAt', 'isPinned', 'isLocked', 'views', 'replyCount', 'likes'])
             && data.id is string
             && data.title is string
             && data.content is string
             && data.category is string
             && data.userId is string
             && data.userName is string
             && data.isPinned is bool
             && data.isLocked is bool
             && data.views is number
             && data.replyCount is number
             && data.likes is number;
    }

    // Helper function to validate thread reply data structure
    function isValidThreadReplyData(data) {
      return data.keys().hasAll(['id', 'threadId', 'content', 'userId', 'userName', 'createdAt', 'isEdited', 'likes'])
             && data.id is string
             && data.threadId is string
             && data.content is string
             && data.userId is string
             && data.userName is string
             && data.isEdited is bool
             && data.likes is number;
    }

    // Helper function to validate poll data structure
    function isValidPollData(data) {
      return data.keys().hasAll(['id', 'question', 'category', 'userId', 'userName', 'createdAt', 'options', 'totalVotes', 'isMultipleChoice', 'allowAddOptions'])
             && data.id is string
             && data.question is string
             && data.category is string
             && data.userId is string
             && data.userName is string
             && data.options is list
             && data.totalVotes is number
             && data.isMultipleChoice is bool
             && data.allowAddOptions is bool;
    }

    // Helper function to check if only thread stats are being incremented
    function isOnlyIncrementingThreadStats(before, after) {
      return after.id == before.id
             && after.userId == before.userId
             && after.userName == before.userName
             && after.title == before.title
             && after.content == before.content
             && after.category == before.category
             && after.createdAt == before.createdAt
             && after.updatedAt == before.updatedAt
             && after.isPinned == before.isPinned
             && after.isLocked == before.isLocked
             // Only allow one stat to change at a time, by exactly 1 or -1
             && (
                 // Views increment by 1
                 (after.views == before.views + 1 && after.likes == before.likes && after.replyCount == before.replyCount)
                 // Likes increment by 1
                 || (after.likes == before.likes + 1 && after.views == before.views && after.replyCount == before.replyCount)
                 // Likes decrement by 1
                 || (after.likes == before.likes - 1 && after.views == before.views && after.replyCount == before.replyCount)
                 // Reply count increment by 1
                 || (after.replyCount == before.replyCount + 1 && after.views == before.views && after.likes == before.likes)
                 // Reply count decrement by 1
                 || (after.replyCount == before.replyCount - 1 && after.views == before.views && after.likes == before.likes)
             );
    }

    // Helper function to check if only poll votes are being updated
    function isOnlyUpdatingPollVotes(before, after) {
      return after.id == before.id
             && after.userId == before.userId
             && after.userName == before.userName
             && after.question == before.question
             && after.category == before.category
             && after.createdAt == before.createdAt
             && after.isMultipleChoice == before.isMultipleChoice
             && after.allowAddOptions == before.allowAddOptions
             // Allow options array to change (vote counts)
             && after.options.size() == before.options.size()
             // Allow totalVotes to increment
             && (after.totalVotes >= before.totalVotes);
    }

    // Content reports collection
    match /content_reports/{reportId} {
      // Only authenticated users can read reports they created
      allow read: if request.auth != null && request.auth.uid == resource.data.reportedBy;

      // Allow authenticated users to create reports
      allow create: if request.auth != null
                    && request.resource.data.reportedBy == request.auth.uid
                    && request.resource.data.keys().hasAll(['id', 'contentId', 'contentType', 'reportedBy', 'reporterName', 'reason', 'details', 'createdAt', 'status'])
                    && request.resource.data.status == 'pending'
                    && request.resource.data.contentType in ['thread', 'reply', 'poll']
                    && request.resource.data.reason in ['spam', 'harassment', 'inappropriate', 'misinformation', 'off-topic', 'other'];

      // Only allow status updates by admins (future feature)
      // For now, reports cannot be updated or deleted by users
      allow update, delete: if false;
    }

    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
